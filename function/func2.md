## 기본 매개변수

함수의 선언에는 매개변수의 형태, 개수를 설정할 수 있다. 설정된 매개변수는 호출문을 통해 그만큼의 인자를 전달받아야 하는데, 충분한 인자를 전달받지 못하면 컴파일 에러를 일으킨다. 
따라서 함수의 호출에는 매번 함수에 전달할 인자를 작성해야 한다. 하지만 해당 함수의 호출이 빈번하고, 반복된 값을 전달할 경우가 많을 경우, 기본 매개변수를 사용해 함수를 간편하게
사용할 수 있다.

기본 매개변수란, 함수를 선언 시 변수 초기화와 같이, 매개변수에 값을 미리 입력하는 것이다. 기본 매개변수는 호출문에서 반드시 전달해야 할 인자의 수에 포함되지 않으며,
기본 매개변수에 값을 전달했다 하더라도, 기본 값은 전달된 값에 덮어 씌워지게 되어 문제가 발생하지 않는다. 다음은 기본 매개변수를 활용한 여러가지 예이다.

1) 기본 매개변수만 존재하는 함수
```c++
#include <iostream>
using namespace std;

int func(int a = 10, int b = 20) {
    return a + b;
}
int main()
{
    cout << func();

    return 0;
}
```
실행 결과
```c++
30
```

위 예의 함수는 매개변수가 존재하지만, 기본 매개변수 값이 설정되어있기에, 호출문에서 인자를 전달하지 않아도, 기본 매개변수 값으로 함수 기능을 수행해 값을 반환한다.
```c++
#include <iostream>
using namespace std;

int func(int a = 10, int b = 20) {
    return a + b;
}
int main()
{
    cout << func(5);

    return 0;
}
```
실행 결과
```c++
25
```
기본 매개변수 값이 설정되어있는 상태에서 인자를 전달하면, 해당 매개변수에 전달된 값이 덮어 씌워진 채로 연산이 수행된다.

2) 매개변수의 일부만 기본 매개변수인 경우
```c++
#include <iostream>
using namespace std;

int func(int a, int b, int c = 10) {
    return a + b + c;
}
int main()
{
    cout << func(5,5);

    return 0;
}
```
실행 결과
```c++
20
```
기본 매개변수를 사용할 때, 주의할 점으로 기본 매개변수는 항상 맨 오른쪽부터 채워나가야 한다. 쉽게 말해, int a = 10, int  b, int c 나, int a, int b = 10, int c 같은 경우는
불가능하고, int a, int b = 10, int c = 10 같은 경우는 가능한 것이다. 그 이유는 인자가 전달될 때, 맨 왼쪽부터 차례대로 매개변수에 입력되기 때문이며, 만약 가운데의 b만
기본 매개변수이고, 나머지가 일반 매개변수일 때, b를 기본 매개변수로 사용하고 c에 값을 전달할 방법이 없기 때문이다. 

두 번째 인자에 기본 매개변수의 값을 넣고 c에 전달할 값을 입력하면 된다고 생각할 수 있지만, 이러면 기본 매개변수를 사용하는 의의가 사라진다.


## 함수 오버로드

함수는 이름이 같아도 사용하는 데이터의 형태가 다르면, 다른 함수로 취급한다. 예를 들어, 두 수의 합을 반환하는 함수 func가 두 개 있다고 할 때, 하나는 매개변수가 정수형이고, 
다른 하나는 매개변수가 실수형이다. 이 때, 메인 함수에서 func 함수를 호출할 때, 인자가 실수일 경우, 실수가 매개변수인 func 함수가 호출되고, 인자가 정수인 경우, 매개변수가 정수인
함수가 호출된다. 다음의 예를 보자.

```c++
#include <iostream>
using namespace std;

int func(int a, int b) {
    return a + b;
}
int func(double a, double b) {
    return a + b;
}
int main()
{
    cout << func(1.5 , 5.3);

    return 0;
}
```
실행 결과
```c++
6
```
이름이 같은 함수가 두 개지만, 메인 함수에서 호출할 때는 매개변수가 실수형인 함수가 호출되었다. 이처럼 함수를 호출할 때, 같은 이름의 함수들 중 
인자 유형에 적절한 함수를 자동으로 찾는 것을 함수 오버로딩이라고 한다. 함수 오버로딩을 사용하면, 데이터의 형태만 다르고 같은 기능을 사용해야 할 때 유용하다.

```c++
#include <iostream>
using namespace std;

int func(int a, int b) {
    return a + b;
}
int func(double a, double b) {
    return a + b;
}
int main()
{
    cout << func(5.3 , 5);

    return 0;
}
```
하지만 다음과 같이 인자의 형태가 double, int일 경우, 컴파일러가 어느 함수로 이동할 지 파악할 수 없기 때문에 컴파일 에러가 발생한다. 


## 기본 매개변수와 함수 오버로드

함수 오버로드는 기본 매개변수의 차이로도 구분될 수 있다. 이를 이용해 빈번히 사용되는 호출 인자를 작성하지 않아도 되어 프로그램의 작성을 효율적으로 할 수 있다.

```c++
#include <iostream>
using namespace std;

int func(int a = 5, int b = 10) {
    return a + b;
}
int func(int a) {
    return a;
}
int main()
{
    cout << func();

    return 0;
}
```
실행 결과
```c++
15
```
만약 위의 예에서 a의 기본 매개변수 값을 없애거나, 호출문에서 하나의 인자를 전달하게 되면 두 함수 모두 적용이 가능해 모호성이 생겨 컴파일 에러를 일으키게 된다.











