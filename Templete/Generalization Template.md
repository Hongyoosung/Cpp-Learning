# 일반화와 템플릿

+ ## 함수 중복의 약점

함수 중복은 코드의 작성에 편리함이 있지만 모든 상황에 적용되는 것은 아니다. 일례로 두 변수의 값을 바꾸어주는 swap() 함수가 있을 때, 자료형에 따라
정수형 변수의 값을 바꾸기 위해서는 swap() 함수의 매개 변수 타입을 정수형으로 선언해야 하고, 실수형 변수의 값을 바꾸기 위해서는 또 다시 매개 변수 타입이 실수형인
swap() 함수를 재작성 해야한다. 이처럼 값을 바꾼다는 동일한 기능을 하는 함수라도 매개 변수 타입에 따라 함수를 여러 번 작성해야 한다. 이렇게 될 경우, 코드가 길어지며
값을 바꾸는 기능에서 다른 기능으로 수정해야 할 경우, 중복된 모든 함수를 같이 수정해야 하는 번거로움이 생긴다.

```c++
// 기능 중복, 다른 타입의 연산을 추가할수록 코드가 길어짐
void swap(int& a, int& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}
void swap(double& a, double& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}
```
이러한 문제를 해결하기 위하여 "찍어내어 만들어 낼 수 있는 틀"이라는 뜻의 **템플릿**이라는 개념이 등장했다. 이 틀을 이용하여 함수나 코드를 찍어내어 양산할 수 있도록 어떤 기능을 가진 틀을 만드는 것을 
**일반화**시키다 라고 한다. 템플릿은 **template**키워드를 사용하며 해당 키워드로 중복 함수들을 일반화시킬 수 있다. 이렇게 일반화된 특별한 함수를
 **템플릿 함수** 또는 **제네릭 함수**라고 한다.
 
 + ## 템플릿 함수의 선언

다음은 두 변수의 값을 바꾸어주는 swap() 함수를 템플릿(제네릭)함수로 일반화시킨 것이다.

```c++
template <class T> // <class T>나 <typename T>로 제네릭 타입 T를 선언
void swap(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}
```

이를 보면 템플릿의 기능이 어림짐작 갈 것이다. 위의 T는 **제네릭 타입**  또는 일반화된 새로운 타입이라는 뜻의 **일반 타입**으로 불린다. 제네릭 타입은 사용자가
원하는 이름을 붙이면 되며, 여러 타입을 선언할 수 있다.
```c++
template <class T1, class T2, class T3>
```

이러한 템플릿의 편의성으로, 현대 추세에는 함수 중복보다는 제네릭 함수를 만들어 사용하는 것이 일반적이다.

템플릿으로 일반화된 제네릭 함수를 다시 역으로 세분화하는 것을 **구체화**라고 하며 이를 통해 생성된 함수를 **구체화 함수**라고 한다. 다음은 구체화의 과정이다.
```c++
template <class T> 
void myswap(T& a, T& b) { // 제네릭 함수
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

int main(int argc, const char* argv[]) {

	int a = 10, b = 20;

	myswap(a, b);       // 함수 호출
	cout << a << endl << b << endl;


	return 0;
}
```
실행 결과
```c++
20
10
```

메인 함수에서 myswap() 함수가 호출될 경우 컴파일러는 소스 파일 내에서 myswap() 함수를 찾는다. 템플릿으로 선언된 myswap() 함수를 찾으면, 호출문의 실인자 타입인
int 형을 제네릭 타입 T에 대입시켜 myswap() 함수를 구체화하고 새로운 소스 코드를 만들어 내어(틀을 이용해 함수를 찍어냄) 실행시킨다.

템플릿 함수 이름이 기존 라이브러리 함수와 이름이 같을 경우 모호성 에러가 발생하니 함수 이름 작성에 주의한다.


+ ## 제네릭 함수 구현

다음은 제네릭 함수와 클래스의 객체를 활용한 예이다.

```c++
class Person {
	int age;
	string name;
public:
	Person() { age = 20; }
	Person(int age, string name) { this->age = age, this->name = name; }
	int getAge() { return age; }
	void show() { cout << name << " : " << age << endl; }
};

template <class T> 
void ageswap(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

int main(int argc, const char* argv[]) {

	Person Jinho(26,"Jinho"), Dohyeon(23,"Dohyeon");

	Jinho.show();
	Dohyeon.show();

	ageswap(Jinho, Dohyeon);

	Jinho.show();
	Dohyeon.show();

	return 0;
}
```
실행 결과
```c++
Jinho : 26
Dohyeon : 23
Dohyeon : 23
Jinho : 26
```
제네릭 타입 T를 통해 두 객체의 정수 타입 멤버인 age 뿐만 아니라 문자열 타입 멤버 name까지 바뀌었다. 이를 통해 제네릭 함수에 객체의 이름이 들어가면
객체의 모든 멤버를 대입하는 것을 알 수 있다.


+ ## 템플릿의 장단점

템플릿으로 선언된 제네릭 함수는 그저 함수를 구체화해주는 틀에 불과하며 컴파일 시 호출되지 않는다. 주의할 점으로, 위의 myswap() 제네릭 함수에서
매개 변수 두 개가 동일한 제네릭 타입 'T' 이므로 전달 인자 또한 동일한 타입이어야 한다.
템플릿은 코드의 재사용성을 높여주어 소프트웨어의 생산성과 유연성을 높여주지만 아직 템플릿을 지원하지 않는 컴파일러가 있어 **포팅에 취약하고**(다른 컴파일러에서
프로그램을 실행하는 것) **디버깅 관련 오류 메시지가 빈약하다** 하지만 여전히 템플릿은 장점이 단점을 상쇄할 만큼 그 가치가 높다.


이러한 템플릿의 특성으로 인해 제네릭 함수나 제네릭 클래스를 통해 프로그램을 작성하는 **제네릭 프로그래밍** 또는 **일반화 프로그래밍**이라 불리는 새로운
프로그래밍 패러다임이 탄생했으며 여러 객체지향 언어에서 지원중이다. 현재까지도 제네릭 프로그래밍은 보편화되고 있으며 여러 라이브러리들이 제네릭으로 수정되는 등
제네릭의 개념은 개발자로서 필수로 이해하고 넘어가야 한다.















