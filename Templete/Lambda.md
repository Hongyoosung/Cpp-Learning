## 람다 대수와 람다식

> 람다 대수에서 유래한 람다식은 수학의 함수를 단순하게 표현하는 방법이다. 단순화된 함수는 이름을 가지지 않으며 **익명 함수** 또는 **람다 함수**, **람다식**이라고 부른다.
> 이러한 특징에 의해 실무적으로는 코드를 간결하게 만들고, 지연 연산으로 성능을 높이며 반복 관련 코드의 불필요한 부분들을 제거할 수 있으므로 중요한 개념이다.
> 람다 함수의 편리성을 얘기하기 위해 예를 든다면, "1부터 10까지 1씩 증가하면서 코드를 실행해" 라고 하는 것 보단 "여기 있는거 다 해" 라고 하는 것이 간결하고 직관성있다.



> 람다식의 기본 구조는 **캡쳐 리스트**,  **매개 변수 리스트**, **리턴 타입**, **함수 바디**의 네 부분으로 구성된다.

#

+ ### 캡쳐 리스트

캡쳐 리스트는 람다식 외부에 선언된 지역 변수나 전역 변수의 목록으로, 람다식에서 해당 변수를 사용하고자 할 때 나열한다. 다음은 캡쳐 리스트의 주요 표현이다.
```c++
  [x] : 변수 x의 값을 활용
  [&x] : 참조 변수 x 활용
  [=] : 모든 변수의 값을 활용
  [&] : 모든 참조 변수를 활용
```

#

+ ### 매개 변수 리스트

일반 함수의 매개 변수 목록과 동일하게 값을 전달받는 곳이다.

#

+ ### 함수 바디

람다식이 호출될 때 실행되는 코드, 일반 함수를 작성하는 방법과 동일하다.

#

+ ### 간단한 람다식 만들기

다음은 매개 변수 x, y의 합을 출력하는 람다식이다.

```c++
int main(int argc, const char* argv[]) {

	[](int x, int y) {cout << "합은 : " << x + y; } (2, 3);

	return 0;
}
```
실행 결과
```c++
합은 : 5
```

#


+ ### auto로 람다식 저장 및 호출

일반적인 방법으로는 람다식을 저장하는 변수를 직접 선언할 수 없다. 하지만 auto를 이용하면 람다식을 저장하는 변수를 쉽게 선언할 수 있다.

```c++

int main(int argc, const char* argv[]) {

	auto speak = [](string a, string b)           // 람다식을 auto 변수 speak에 저장
	{cout << a << "는 " << b << "이다." << endl; };

	speak("진호", "바보");     // 변수 speak를 통해 람다식을 호출문처럼 사용 가능
	speak("나", "신");

	return 0;
}
```
실행 결과
```c++
진호는 바보이다.
나는 신이다.
```

+ ## 캡쳐 리스트와 리턴 타입을 가지는 람다식

캡쳐 리스트를 통해 람다식에 외부 변수들의 값을 복사하거나 참조할 수 있다. 
```c++
int main(int argc, const char* argv[]) {

	// 입력받은 수의 제곱을 리턴하는 람다식
	cout << "func 1" << endl;
	int c;
	cout << "수를 입력하세요" << endl;
	cin >> c;

	auto pow = [c](int a) -> int {return a * a; };
	cout << "입력한 수의 제곱은 : " << pow(c) << endl;

	// 두 수의 값을 서로 바꾸어주는 람다식
	cout << endl << "func 2" << endl;
	int a = 10, b = 20;
	[a, b](int& x, int& y) {int tmp; tmp = x; x = y; y = tmp; }(a, b);

	cout << "a : " << a << ' ' << "b : " << b << endl;


	// 합을 외부에 저장하는 람다식
	cout << endl << "func 3" << endl;
	int sum = 0;
	[&sum](int x, int y) {sum = x + y; }(100, 200);
	
	cout << sum << endl;

	return 0;
}
```
실행 결과
```c++
func 1
수를 입력하세요
5
입력한 수의 제곱은 : 25

func 2
a : 20 b : 10

func 3
300
```

#

+ ## STL 템플릿에 람다식 활용


람다식은 STL 템플릿을 사용할 때 더욱 유용하다. 다음은 STL 함수 for_each()를 이용해 벡터의 모든 원소를 출력하는 코드이다.
```c++
void print(int n) {
	cout << n << " ";
}

int main(int argc, const char* argv[]) {

	vector<int> v = { 1,2,3,4,5 };

	// 벡터 v의 첫 번째 원소부터 끝까지 검색하면서 각 원소에 대하여 print 함수를 호출
	// 매개 변수 n에 각 원소 값을 전달
	for_each(v.begin(), v.end(), print);

	return 0;
}
```
실행 결과
```c++
1 2 3 4 5
```

다음은 위의 print 함수를 람다식으로 작성한 것이다.
```c++
int main(int argc, const char* argv[]) {

	vector<int> v = { 1,2,3,4,5 };

	// print 함수를 람다식으로 작성
	for_each(v.begin(), v.end(), [](int n) {cout << n << " "; });

	return 0;
}
```

#

+ ### 람다식의 장점

  + 이름을 작성하지 않기 때문에 한 번 호출하고 재사용하지 않을 함수에 유용하다(그렇다고 재사용이 힘든 것은 아님).
  + STL 알고리즘 함수의 매개 변수에 연산 코드를 넣을 때 유용하다.
  
+ ### 람다식의 단점

  + 어떤 방법으로 작성해도 모든 원소를 전부 순회하는 경우는 람다식이 조금 느릴 수밖에 없다. 
  + 람다식을 남용하면 오히려 코드를 이해하기 어려울 수 있다.










































