# 동적 메모리

지금까지 프로그래밍에서 변수를 선언하는 등 메모리에 저장공간을 할당하는 행위를 정적 메모리 할당이라고 한다. 정적으로 할당된 저장공간은 프로그램 실행 중 그 크기를 유지하며 변경될 수
없다. 이로 인해 발생하는 문제로 예를 들면, 프로그램 작성 시 배열로 저장 공간 100개를 선언하였지만, 프로그램 사용자가 배열 인덱스를 5개만 사용했다고 하자. 이럴 경우, 나머지 인덱스 95개는
낭비되는 공간이며 프로그램의 메모리 효율을 급감시킨다. 이러한 문제를 해결하기 위해 필요한 만큼 메모리를 할당하고 필요가 없어질 때 할당을 해지하는 것을 동적 메모리 할당이라고 한다.


동적 메모리의 할당과 반환은 **new**와 **delete** 연산자를 이용하며, new 사용 시 힙(heap)이라는 메모리 공간으로부터 저장 공간을 할당받고, delete는 할당 받은 저장 공간을 힙으로 다시
반환한다.
>힙(heap)이란
>힙 영역은 사용자가 직접 관리해야만 하는 메모리 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다(C++의 new() 함수를 사용한다). 힙 영역은 할당 순서에 따라 할당되는 
>주소 값이 낮은 주소 값에서 높은 주소 값으로 커진다.
> 힙 영역의 데이터는 메모리 주소 값에 의해서만 참조되고 사용된다. 그러므로 힙 영역은 포인터 변수를 통해서 참조된다.
> 
> 인용 : https://github.com/geunkim/CPPLectures/blob/master/MemoryModelAndNameSpace/Memory_Model.md

+ ## 동적 메모리 구현

C++의 기본 연산자인 new와 delete를 활용하여 동적 메모리를 구현해본다.

```c++
(자료형) *(포인터변수) = new (자료형)
delete *(포인터변수);
```

동적 메모리 할당은 포인터 변수로 이루어짐을 알 수 있다. new 연산자는 자료형의 크기만큼 힙으로부터 메모리를 할당받고 주소를 반환한다. 따라서 포인터 변수는 할당받은 저장공간의
주소를 가지게 되며 delete 연산자를 통해 해당 포인터 변수가 가리키는 저장공간을 힙으로 다시 반환할 수 있다. 이 때, 자료형에는 기본 자료형 외에 구조체나 클래스도 사용할 수 있다.
다음은 동적 메모리를 할당받고 해지하는 코드이다.

```c++
int main(int argc, const char* argv[]) {

  // 다양한 데이터 타입의 동적 메모리 할당
	int* pint = new int;
	double* pdouble = new double;
	Man* pMan = new Man(); // 클래스 Man의 동적 메모리 할당, 뒤에 ()를 주의한다.

  // 각 동적 메모리 해지
	delete pint;
	delete pdouble;
	delete pMan;
	
	return 0;
}
```

만일 동적 메모리 할당 중 힙의 메모리가 부족하면 new는 NULL을 반환한다. 따라서 동적 메모리 할당 시 new가 NULL을 반환하는지
검사하는 것이 좋다. 다음은 int 타입의 동적 메모리를 할당받고 사용 후 해지하는 과정이다.

```c++
int main(int argc, const char* argv[]) {

	int* p = new int; // 힙으로부터 int 타입의 저장공간 할당
	int* q = new int(20); // 동적 변수를 20으로 초기화

	if (!p) { // if(p==NULL) 과 동일, p가 NULL이면 메모리 할당 실패
		return 0;
	}

	*p = 5;  // p가 가리키는 저장공간에 5를 저장

	int n = *p; // p가 가리키는 곳에 저장된 값을 n에 저장

	cout << n << endl << *q << endl;

  // 저장공간 반환
	delete p; 
	delete q;

	return 0;
}
```
실행 결과
```c++
5
20
```

물론 이미 메모리가 해지된 변수는 다시 사용할 수 없다.

```c++
int main(int argc, const char* argv[]) {

	int* p = new int; 
	
	if (!p) { 
		return 0;
	}
	
	*p = 5;
	
	delete p; // 메모리 해지
	
	cout << *p << endl;   // 런타임 에러 발생, *p가 가리키는 저장공간이 없음

	return 0;
}
```

+ ## 배열의 동적 할당 및 반환

일반 변수를 동적 할당 했듯, 배열 또한 동적 할당이 가능하다. 다음은 그 예시이다.


```c++
int main(int argc, const char* argv[]) {

	int* p = new int[5]; // 정수형 동적 배열 선언
	int n = 10;
	int* q = new int[n]; // 인덱스에 값이 저장된 변수를 삽입할 수 있다
	int* w = new int[] {1, 2, 3, 4}; // 1, 2, 3, 4로 초기화된 정수 배열 동적 생성


	
	if (!p || !q || !w) return 0; // NULL 검사
	
	cout << "배열 q 출력" << endl << endl;
	for (int i = 0; i < 5; i++) {
		p[i] = i + 1;
		cout << i + 1 << "번 째 배열 출력 : " << p[i] << endl;
	}

	cout << endl << "배열 q 출력" << endl << endl;

	for (int i = 0; i < n; i++) {
		q[i] = i + 10;
		cout << i + 1 << "번 째 배열 출력 : " << q[i] << endl;
	}
	
	cout << endl << "배열 w 출력" << endl << endl;
	
	for (int i = 0; i < 4; i++) {
		w[i] = i + 100;
		cout << i + 1 << "번 째 배열 출력 : " << w[i] << endl;
	}

  // 배열의 저장공간 반환
	delete[] p;
	delete[] q;
	delete[] w;

	return 0;
}
```
실행 결과
```c++
배열 q 출력

1번 째 배열 출력 : 1
2번 째 배열 출력 : 2
3번 째 배열 출력 : 3
4번 째 배열 출력 : 4
5번 째 배열 출력 : 5

배열 q 출력

1번 째 배열 출력 : 10
2번 째 배열 출력 : 11
3번 째 배열 출력 : 12
4번 째 배열 출력 : 13
5번 째 배열 출력 : 14
6번 째 배열 출력 : 15
7번 째 배열 출력 : 16
8번 째 배열 출력 : 17
9번 째 배열 출력 : 18
10번 째 배열 출력 : 19

배열 w 출력

1번 째 배열 출력 : 100
2번 째 배열 출력 : 101
3번 째 배열 출력 : 102
4번 째 배열 출력 : 103
```

동적 생성된 배열을 초기화할 때는 위와 같은 방법만 사용해야 한다는 것을 유의한다.


















