# 연산자 오버로드

함수 오버로드를 사용하면 같은 이름의 함수가 서로 다른 기능을 할 수 있다. 연산자 또한 마찬가지로 일반적인 의미의 '+'는 두 수를 더하는 연산자이지만 연산자 오버로드를
사용하면, 같은 '+'기호를 다른 의미로 사용할 수 있다. 
따라서 연산자 오버로드를 사용하면 같은 기호로 대상에 따라 서로 다른 연산이 가능하게 하는 일종의 **다형성**이 구현된다.

다음은 연산자 오버로드의 특징이다

+ 본래 존재하는 연산자만 오버로드가 가능하다. 단, 기존에 있던 것 중에도 사용하지 못하는 것이 있다(' . ', ' .* ',  ' :: ', ' ?: ').

+ 오버로드를 사용할려면 '객체 + 객체'나 '객체 + 수'와 같은 기존의 '수 + 수'와 다른 개념의 연산을 구현해야 한다.

+ 연산자 오버로드는 피연산자로 객체를 사용하므로 클래스의 멤버 함수로 구현된다.

+ 피연산자의 개수나 기존의 연산 우선순위를 바꿀 순 없다.


+ ## 연산자 오버로드 구현

연산자 오버로드는 연산자 함수를 통해 구현하므로, 클래스의 멤버 함수로 구현하거나, 외부 함수로 구현하고 클래스의 프렌드 함수로 선언하는 방법이 있다.
연산자 함수도 함수이므로 자료형과 매개 변수를 가지지만 이름이 없고 **operator** 키워드가 들어간다. 
```c++
(자료형) opreator (연산자)(매개변수 리스트);
```

  + ### 외부 함수로 구현 후 클래스에 프렌드로 선언

```c++
// 전역 공간에 선언
Color operator + (Color op1, Color op2); /
bool operator == (Color op1, Color op2);

class Color {
public:
	// 프렌드 선언
	friend Color operator + (Color op1, Color op2);
	friend bool operator == (Color op1, Color op2);
};
```

  + ### 클래스의 멤버 함수로 선언

```c++
class Color {
public:
	
	Color operator + (Color op2);
	bool operator == (Color op2);
};
```

  + ### 위 두 방법은 다음과 같이 사용됨

```c++
Color a(BLUE), b(RED), c;
c = a + b;     // Color operator + (Color op2) 호출

if (a == b) {  // bool operator == (Color op2); 호출

}

```
















