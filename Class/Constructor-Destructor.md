# 생성자

객체를 특정 값으로 초기화해주는 명령어. 객체가 생성될 때 필요한 초기 작업이 목적이며, 생성자가 있는 클래스에서 객체를 생성하면, 해당 객체는 생성자에 의해 기본적인 값을 지닌 채
생성되며, 생성자는 해당 시점에서 단 한번만 실행된다. 

생성자도 하나의 함수이므로 멤버 함수의 선언과 유사하다. 하지만 생성자와 멤버 함수의 차이점은 다음과 같다.
+ 생성자는 반환 값이 없다. 그러므로 void 포함 어떤 자료형도 명시해선 안된다.
+ 생성자 이름은 클래스의 이름과 같다.
+ 생성자는 객체 생성 시 자동으로 실행된다.
+ 객체에 인자를 작성하여 생성자에 값을 전달할 수 있다.
+ 생성자는 전달받는 데이터 형태의 차이를 이용하여 여러 개를 구현할 수 있다.

+ ## 생성자의 구현



다음은 생성자가 구현된 클래스의 예이다.

```c++
#include <iostream>
using namespace std;

class Man {
	int age;
public:
	Man();            //생성자 1
	Man(int age);     //생성자 2, 매개 변수가 있음
	int getAge();
};
Man::Man() {        //생성자 1 구현, 멤버 변수의 값 설정
	age = 23;
	cout << "생성자 1 실행" << endl;
}

Man::Man(int age) { //생성자 2 구현, 전달받은 인자를 멤버 변수에 입력
	this->age = age;
	cout << "생성자 2 실행" << endl;		
}                         
//매개변수와 멤버 변수의 이름이 같은 경우, 멤버 변수 앞에 this 포인터를 붙여주어 데이터가
//매개 변수가 아닌 멤버 변수로 올바르게 입력되도록 한다. 이는 멤버 함수 구현에도 해당된다.
 //this 포인터 : 객체 자기 자신을 가리키는 포인터
int Man::getAge() {                    
	return age;
}

int main(int argc, const char* argv[]) {

	Man a(10);         //객체 생성 시, 매개변수가 있는 생성자 2 실행, 10을 전달
	Man b;             //객체 생성 시, 매개변수가 없는 생성자 1 실행

	cout << a.getAge() << endl << b.getAge();

	return 0;
}
```
실행 결과
```c++
생성자 2 실행
생성자 1 실행
10
23
```
결과를 보면 알 수 있듯, 생성자가 여러 개라도, 객체의 형태에 맞는 생성자만 실행된다. 이는 함수 오버로드의 형태와 유사하다고 볼 수 있다.

+ ## 위임 생성자

생성자들은 객체의 값을 초기화한다는 특성 상 서로 중복된 코드를 공유하고 있다. 이러한 중복을 줄이기 위해 하나의 생성자에 다른 생성자를 추가할 수 있는 방법이 있다.

```c++
#include <iostream>
using namespace std;

class Man {
	int age;
public :
	Man();
	Man(int age);
	int getAge();
};

Man::Man() : Man(23) {} //위임 생성자

Man::Man(int age) {     //타겟 생성자
	this->age = age;
}
int Man::getAge() {
	return age;
}



int main(int argc, const char* argv[]) {

	Man a(10);
	Man b;

	cout << a.getAge() << endl << b.getAge();
	
	return 0;
}
```
실행 결과는 이전의 코드와 동일하다. 객체가 생성될 때, 먼저 위임 생성자가 실행된다. 위의 경우, 위임 생성자에서 전달받은 값이 없을 때, 타겟 생성자에게 23을 전달한다.
만약 전달받은 값이 있을 경우, 해당 값을 그대로 타겟 생성자에게 전달한다. 이처럼 객체의 생성을 자신이 하지 않고 다른 생성자에게 위임하는 생성자를 위임 생성자, 위임받는 생성자를
타겟 생성자라고 한다.

+ ## 멤버 변수 초기화의 방법

생성자에서 멤버 변수를 초기화할 때, 위 처럼 대입연산자를 사용하는 방법 외에도 여러가지 방법이 있다.
```c++
class Point {
	int x, y;
public :
	Point();
	Point(int x);
	Point(int x, int b);
};

Point::Point() : x(0), y(0) {}             // 멤버 변수 x와 y를 0으로 초기화

Point::Point(int a) : x(a), y(0) {}        // a와 0으로 초기화

Point::Point(int a) : x(100+a), y(100) {}  // 100+a와 100으로 초기화

Point::Point(int a, int b) : x(a), y(b) {} // a와 b로 초기화

```

+ ## 기본 생성자

이전에 생성자가 없는 클래스를 구현할 때, 컴파일 에러 없이 동작한 것을 보면, 생성자가 굳이 필요하지 않다고 볼 수도 있다. 하지만 컴파일러는 클래스에 생성자가 구현되어 있지 않았을 때,
스스로 기본 생성자를 만들어 자동으로 삽입한다. 기본 생성자는 매개변수가 없는 생성자이며, 아무 기능을 하지 않는다. 따라서 생성자는 기본적으로 모든 클래스에 필수로 들어간다고 
볼 수 있다. 단, 하나의 생성자라도 존재할 경우, 컴파일러는 기본 생성자를 삽입하지 않는다. 따라서 객체와 생성자 간의 매개변수를 유심해야한다.



# 소멸자

소멸자는 생성자와 반대로 객체가 소멸할 때 실행되는 함수이다. 객체는 변수와 같이 프로그램 실행 중 생성된 범위를 벗어나면 자동으로 할당받은 저장공간을 반환하고 소멸된다.

소멸자는 다음과 같은 특징을 가지고 있다.

+ 소멸자의 이름은 클래스 이름 앞에 ~를 붙인다.
+ 소멸자 또한 반환값이 없으며 자료형을 명시하지 않는다.
+ 소멸자는 오직 한개이며, 매개 변수가 존재하지 않는다.
+ 소멸자가 구현되어 있지 않으면 기본 소멸자가 생성된다.


+ ## 소멸자의 구현
```c++
#include <iostream>
using namespace std;

class Man {
	int age;
public:
	Man();
	Man(int age);
	~Man();      // 소멸자 선언
	int getAge();
};
Man::Man() : age(23) { cout << "age : " << age << " 생성" << endl; } // 기본 생성자, age에 23 대입

Man::Man(int age) {
	this->age = age;
	cout << "age : " << age << " 생성" << endl;
}
Man::~Man() {
	cout << "age : " << age << " 소멸" << endl;
}
int Man::getAge() {
	return age;
}

int main(int argc, const char* argv[]) {

	Man a(10);
	{
		Man b;
	}
	Man c(30);

	return 0;
}
```
실행 결과
```c++
age : 10 생성
age : 23 생성
age : 23 소멸
age : 30 생성
age : 30 소멸
age : 10 소멸
```
메인 함수에서 생성된 객체는 리턴문 이후 메인 함수가 종료될 때 각 소멸자를 실행한다. 단, 객체 b는 메인 함수 내에 존재하는
별도의 공간에서 생성되고 해당 공간이 종료되자 b도 사라지는 것을 알 수 있다. 소멸자의 실행 순서로 보아 객체는 생성된 순서의 반대로 소멸되는
후입선출의 형태를 띄고 있음을 알 수 있다. 다음은 위 코드에서 객체들의 생성과 소멸 과정을 표현한 것이다.
```c++
메인 함수 시작
a 생성

{ 진입
b 생성
} 종료
b 소멸

c 생성

메인 함수 종료

c 소멸
a 소멸
```













