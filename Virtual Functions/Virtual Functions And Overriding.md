# 가상 함수와 오버라이딩

+ ## 함수 재정의

상속 관계의 클래스에서, 파생 클래스에 기본 클래스의 동일한 이름과 형태의 함수를 **재정의**하여 다른 기능을 하도록 작성할 수 있다. 다음은 함수 재정의의 예시이다.
```c++
class Person {
	int age = 20;
public:
	void show() { cout << age << endl; }
};

class Man : public Person {
	int money = 100;
public:
	void show() { cout << money << endl; } // Person의 멤버 함수를 재정의
 };


int main(int argc, const char* argv[]) {

	Person a;
	a.show();

	Man b;
	b.show();

	return 0;
}
```
실행 결과
```c++
20
100
```

여기서 알아야 할 점으로, Man은 Person을 상속받고 있기 때문에, b의 저장 공간에는 같은 이름의 함수인 show가 두 개 있다는 것이다. 하지만 실행은 의도대로 
파생 클래스 객체에서 재정의된 함수가 문제없이 실행되었다.
이는 컴파일러가 여러 클래스에 정의된 멤버를 호출할 때, 그 객체의 클래스 멤버를 우선시하기 때문이다. 이로 인해, 업캐스팅으로 기본 클래스의 포인터가
파생 클래스의 객체를 가리킨다 할지라도, 해당 포인터 클래스로 재정의된 함수를 호출할 때, 기본 클래스의 함수가 실행된다. 
이러한 호출 관계가 컴파일 시에 이루어지는 것을 **정적 바인딩**이라고 한다.

범위연산자( :: )를 사용하여 호출 관계에 상관없이 객체를 통해 원하는 재정의 멤버가 접근할 수 있다.
```c++
Man b;
	b.show();
	b.Person::show(); // Person의 show 멤버를 호출
  ```
  
  실행 결과
  ```c++
  100
  20
```
  이러한 재정의 기술은 파생 클래스에서 기본 클래스의 멤버 함수를 활용할 수 없는 경우, 파생 클래스에서 동일한 원형으로 재정의하여 문제를 해결할 때 사용된다.
  
  + ## 가상 함수와 오버라이딩


  









