# 가상 함수와 오버라이딩

+ ## 함수 재정의

상속 관계의 클래스에서, 파생 클래스에 기본 클래스의 동일한 이름과 형태의 함수를 **재정의**하여 다른 기능을 하도록 작성할 수 있다. 다음은 함수 재정의의 예시이다.
```c++
class Person {
	int age = 20;
public:
	void show() { cout << age << endl; } // 함수 선언
};

class Man : public Person {
	int money = 100;
public:
	void show() { cout << money << endl; } // 함수 재정의
 };


int main(int argc, const char* argv[]) {

	Man b, * pMan;
	pMan = &b;
	pMan->show();

	Person a, *pPerson;
	pPerson = &b;       // 업캐스팅으로 객체 b를 가리킴
	pPerson->show();
	a.show();          

	return 0;
}
```
실행 결과
```c++
100
20
20
```

여기서 알아야 할 점으로, Man은 Person을 상속받고 있기 때문에, b의 저장 공간에는 같은 이름의 함수인 show가 두 개 있다는 것이다. 하지만 실행은 의도대로 
파생 클래스 객체에서 재정의된 함수가 문제없이 실행되었다.
이는 컴파일러가 여러 클래스에 정의된 멤버를 호출할 때, 그 객체의 클래스 멤버를 우선시하기 때문이다. 이로 인해, 업캐스팅으로 기본 클래스의 포인터가
파생 클래스의 객체를 가리킨다 할지라도, 해당 포인터 클래스로 재정의된 함수를 호출할 때, 기본 클래스의 함수가 실행된다. 
이러한 호출 관계가 컴파일 시에 미리 이루어지는 것을 **정적 바인딩**이라고 하고, 컴파일 후 프로그램 실행 중에 이루어지는 것을 **동적 바인딩**이라고 한다.

범위연산자( :: )를 사용하여 호출 관계에 상관없이 객체를 통해 원하는 재정의 멤버가 접근할 수 있다.
```c++
Man b;
	b.show();
	b.Person::show(); // Person의 show 멤버를 호출
  ```
  
  실행 결과
  ```c++
  100
  20
```
  이러한 재정의 기술은 파생 클래스에서 기본 클래스의 멤버 함수를 활용할 수 없는 경우, 파생 클래스에서 동일한 원형으로 재정의하여 문제를 해결할 때 사용된다.
  
  + ## 가상 함수와 오버라이딩

먼저 **오버라이딩**이란, 파생 클래스에서 기본 클래스에 작성된 가상 함수를 재정의하여, 기본 클래스의 가상 함수를 무력화시키고 오직 자신만이
실행되게 한다. 이 때, 기본 클래스나 파생 클래스의
포인터로 가상 함수를 호출하면 항상 파생 클래스의 오버라이딩된 함수가 실행된다.

**가상 함수**란 virtual 키워드로 선언된 멤버 함수이며, virtual 키워드는 컴파일러가 해당 키워드가 있는 명령어의 호출 바인딩을 실행 시간까지 미루도록 지시한다.
가상 함수는 기본 클래스나 파생 클래스 어디든 선언될 수 있으며 다음과 같이 선언한다.
```c++
class Person {
	int age = 20;
public:
	virtual void show() { cout << age << endl; }
};
```

파생 클래스에서 기본 클래스의 가상 함수를 재정의하는 것을 **함수 오버라이딩** 또는 그냥 **오버라이딩**이라고 부른다. 함수의 재정의가 **컴파일 시간 다형성**이면, 
오버라이딩은 **실행 시간 다형성**을 실현한다.

다음은 가상 함수의 선언과 오버라이딩의 간단한 예시이다.

```c++
class Person {
	int age = 20;
public:
	virtual void show() { cout << age << endl; } // 가상 함수 선언
};

class Man : public Person {
	int money = 100;
public:
	virtual void show() { cout << money << endl; } // 기본 클래스의 가상 함수를 재정의, 물론 virtual 키워드를 붙인다
 };


int main(int argc, const char* argv[]) {

	Man b, * pMan;
	pMan = &b;
	pMan->show();

	Person a, *pPerson;
	pPerson = &b;       // 업캐스팅으로 객체 b를 가리킴
	pPerson->show();
	a.show();          // 포인터 접근이 아니면 오버라이딩 적용 안됨

	return 0;
}
```
실행 결과
```c++
100
100
20
```

가상 함수를 사용할 때와 사용하지 않을 때의 차이점으로, 포인터를 통한 재정의 함수 호출이 모두 파생 클래스의 가상 함수를 호출한다는 것이다. 이는 파생 클래스에서
가상 함수 재정의에 의해 오버라이딩이 이루어져 기존의 가상 함수가 무력화되었기 때문이다. 따라서 재정의된 가상 함수의 포인터 접근은 모두 오버라이딩된 함수만을 실행한다.
가상 함수 오버라이딩은  컴파일 후 실행 시간 중에 호출 관계가 변경되는 **동적 바인딩**을 따른다.

이러한 오버라이딩은 기본 클래스의 가상 함수 선언으로 파생 클래스가 사용할 함수의 틀을 제공하고 하나의 틀을 통해 서로 다른 형태의 구현을 가능하게 하기에 객체 지향 언어의
**다형성**을 실현한다.










